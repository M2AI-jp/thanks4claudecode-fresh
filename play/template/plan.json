{
  "_template_rules": {
    "_philosophy": {
      "principle": "LLM は提案者、ルールは裁判官。キーワード禁止は無意味（言い換え可能）。行動パターンを禁止する。",
      "reference": "claude-code-harness の implementation-quality.md / test-quality.md"
    },
    "criterion": {
      "MUST": [
        "State a single, atomic condition that is either true or false",
        "Be verifiable by exactly one command execution",
        "Describe observable state, not action or intent"
      ],
      "PROHIBITED_PATTERNS": {
        "hollow_criterion": {
          "description": "A criterion that cannot fail or proves nothing",
          "examples": ["ファイルが適切に設定されている", "正しく動作する", "問題なく完了する"],
          "why_prohibited": "Cannot be falsified - always passes by interpretation"
        },
        "compound_criterion": {
          "description": "A criterion that tests multiple independent conditions",
          "examples": ["ファイル X が存在し、関数 Y が定義されている", "A が B で、C が D である"],
          "why_prohibited": "If one fails, which failed? Split into separate criteria."
        },
        "action_criterion": {
          "description": "A criterion written as an action to perform",
          "examples": ["ファイルを作成する", "テストを実行する", "設定を確認する"],
          "why_prohibited": "Criterion describes state, not action. Use past participle or existence."
        }
      },
      "SELF_CHECK": [
        "Can this criterion fail? If not, it's hollow.",
        "Does this criterion test exactly one thing? If not, split it.",
        "Is this describing state (what IS) or action (what TO DO)? Must be state."
      ]
    },
    "command": {
      "MUST": [
        "Be a valid shell command that can be copy-pasted and executed",
        "Return a verifiable exit code or output",
        "Test exactly one condition (no && or ; chaining)"
      ],
      "PROHIBITED_PATTERNS": {
        "pseudo_command": {
          "description": "Instructions disguised as commands",
          "examples": ["Execute the test", "Compare with expected", "Manually verify"],
          "why_prohibited": "Not executable. Must be actual shell command."
        },
        "compound_command": {
          "description": "Multiple commands chained together",
          "examples": ["test -f path && grep -q 'pattern' path", "cmd1; cmd2"],
          "why_prohibited": "Which command failed? Split into separate validations."
        },
        "trivial_command": {
          "description": "Commands that always succeed",
          "examples": ["echo 'done'", "true", "exit 0"],
          "why_prohibited": "Proves nothing. Command must actually test something."
        }
      },
      "SELF_CHECK": [
        "Can I paste this into a terminal right now? If not, rewrite.",
        "Does this command test exactly one thing?",
        "Can this command fail when the criterion is not met?"
      ]
    },
    "expected": {
      "MUST": [
        "Be a concrete, observable value or exit code",
        "Be comparable by machine (not human interpretation)"
      ],
      "PROHIBITED_PATTERNS": {
        "subjective_expected": {
          "description": "Values requiring human judgment",
          "examples": ["適切な値", "正常終了", "期待通り"],
          "why_prohibited": "Machine cannot evaluate 'appropriate'. Use concrete value."
        },
        "universal_expected": {
          "description": "Values that sound complete but mean nothing",
          "examples": ["All pass", "100% success", "No errors"],
          "why_prohibited": "What is 'all'? Define the specific check."
        }
      },
      "VALID_FORMS": ["exit 0", "exit 1", ">= N", "== N", "contains 'X'", "exact string"]
    },
    "subtask": {
      "MUST": [
        "Represent exactly one state change",
        "Have exactly one criterion"
      ],
      "PROHIBITED_PATTERNS": {
        "omnibus_subtask": {
          "description": "A subtask that does too many things",
          "examples": ["ファイル作成、テスト追加、ドキュメント更新を行う"],
          "why_prohibited": "Which part failed? One subtask = one verifiable change."
        }
      }
    },
    "anti_fraud": {
      "hollow_implementation": {
        "description": "Code that appears to work but doesn't actually do anything",
        "examples": [
          "Hardcoding test answers",
          "Returning fixed values instead of computing",
          "Stubbing with empty implementations"
        ],
        "detection": "Run with inputs not in test cases. Does it still work?"
      },
      "test_tampering": {
        "description": "Modifying tests to pass instead of fixing implementation",
        "examples": [
          "Changing expected values to match actual errors",
          "Adding skip() to failing tests",
          "Removing assertions"
        ],
        "rule": "Fix implementation, not tests. Test changes require user approval."
      },
      "evidence_fabrication": {
        "description": "Creating fake evidence of completion",
        "examples": [
          "Manually writing 'PASS' in logs",
          "Copying old success outputs",
          "Editing timestamps"
        ],
        "rule": "Evidence must be from actual command execution, not manual creation."
      }
    }
  },
  "format_version": "2.3",
  "meta": {
    "id": "example-playbook-id",
    "branch": "feat/example-feature",
    "created": "YYYY-MM-DD",
    "status": "draft",
    "review_profile": "standard",
    "reviewed": false,
    "reviewed_by": "",
    "roles": {
      "orchestrator": "claudecode",
      "worker": "codex",
      "reviewer": "coderabbit",
      "human": "user"
    }
  },
  "goal": {
    "summary": "Implement X to achieve Y (one sentence, specific)",
    "done_when": [
      {
        "criterion": "src/feature.ts が存在する",
        "command": "test -f src/feature.ts",
        "expected": "exit 0"
      },
      {
        "criterion": "src/feature.ts に export function X が含まれる",
        "command": "grep -c 'export function X' src/feature.ts",
        "expected": ">= 1"
      },
      {
        "criterion": "npm test が exit 0 で終了する",
        "command": "npm test",
        "expected": "exit 0"
      }
    ],
    "scope": {
      "includes": ["List specific files or features"],
      "excludes": ["List what is NOT in scope"]
    }
  },
  "context": {
    "analysis_result": {
      "source": "prompt-analyzer",
      "data": {}
    },
    "user_approved_understanding": {
      "source": "",
      "approved_at": "",
      "summary": "",
      "approved_items": [],
      "technical_requirements_confirmed": []
    }
  },
  "max_iterations": 5,
  "phases": [
    {
      "id": "p1",
      "name": "Implementation",
      "description": "Implement the core feature",
      "depends_on": [],
      "subtasks": [
        {
          "id": "p1.1",
          "criterion": "src/feature.ts が存在する",
          "executor": "codex",
          "coding": true,
          "validation_plan": {
            "technical": {
              "type": "automated",
              "command": "test -f src/feature.ts",
              "expected": "exit 0"
            },
            "consistency": {
              "type": "automated",
              "command": "grep -c 'import.*feature' src/index.ts",
              "expected": ">= 1"
            },
            "completeness": {
              "type": "automated",
              "command": "jq '.compilerOptions.strict' tsconfig.json",
              "expected": "true"
            }
          }
        }
      ]
    },
    {
      "id": "p_final",
      "name": "Final verification",
      "description": "Execute all done_when commands and verify results",
      "depends_on": ["p1"],
      "subtasks": [
        {
          "id": "p_final.1",
          "criterion": "src/feature.ts が存在する（done_when[0]）",
          "executor": "coderabbit",
          "coding": false,
          "validation_plan": {
            "technical": {
              "type": "automated",
              "command": "test -f src/feature.ts",
              "expected": "exit 0"
            },
            "consistency": {
              "type": "automated",
              "command": "ls -la src/feature.ts",
              "expected": "file exists"
            },
            "completeness": {
              "type": "automated",
              "command": "file src/feature.ts",
              "expected": "text"
            }
          }
        },
        {
          "id": "p_final.2",
          "criterion": "src/feature.ts に export function X が含まれる（done_when[1]）",
          "executor": "coderabbit",
          "coding": false,
          "validation_plan": {
            "technical": {
              "type": "automated",
              "command": "grep -c 'export function X' src/feature.ts",
              "expected": ">= 1"
            },
            "consistency": {
              "type": "automated",
              "command": "grep 'export function X' src/feature.ts",
              "expected": "not empty"
            },
            "completeness": {
              "type": "automated",
              "command": "wc -l src/feature.ts",
              "expected": ">= 1"
            }
          }
        },
        {
          "id": "p_final.3",
          "criterion": "npm test が exit 0 で終了する（done_when[2]）",
          "executor": "coderabbit",
          "coding": false,
          "validation_plan": {
            "technical": {
              "type": "automated",
              "command": "npm test",
              "expected": "exit 0"
            },
            "consistency": {
              "type": "automated",
              "command": "npm run test:unit",
              "expected": "exit 0"
            },
            "completeness": {
              "type": "automated",
              "command": "npm run lint",
              "expected": "exit 0"
            }
          }
        }
      ]
    }
  ],
  "final_tasks": []
}
