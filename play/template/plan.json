{
  "_template_rules": {
    "_philosophy": {
      "principle": "LLM は提案者、ルールは裁判官。キーワード禁止は無意味（言い換え可能）。行動パターンを禁止する。",
      "reference": "claude-code-harness の implementation-quality.md / test-quality.md"
    },
    "criterion": {
      "MUST": [
        "State a single, atomic condition that is either true or false",
        "Be verifiable by exactly one command execution",
        "Describe observable state, not action or intent",
        "Be semantically aligned with its verification command"
      ],
      "PROHIBITED_PATTERNS": {
        "hollow_criterion": {
          "description": "A criterion that cannot fail or proves nothing",
          "examples": ["ファイルが適切に設定されている", "正しく動作する", "問題なく完了する"],
          "why_prohibited": "Cannot be falsified - always passes by interpretation"
        },
        "compound_criterion": {
          "description": "A criterion that tests multiple independent conditions",
          "examples": ["ファイル X が存在し、関数 Y が定義されている", "A が B で、C が D である"],
          "why_prohibited": "If one fails, which failed? Split into separate criteria."
        },
        "action_criterion": {
          "description": "A criterion written as an action to perform",
          "examples": ["ファイルを作成する", "テストを実行する", "設定を確認する"],
          "why_prohibited": "Criterion describes state, not action. Use past participle or existence."
        },
        "proxy_criterion": {
          "description": "Criterion that tests existence/syntax when semantics matter",
          "examples": ["関数が定義されている（when logic correctness matters）", "ファイルが存在する（when content correctness matters）"],
          "why_prohibited": "Existence != correctness. Test the actual behavior, not its proxy."
        },
        "tautological_criterion": {
          "description": "Criterion that cannot logically fail",
          "examples": ["0件以上存在する", "ファイルの内容がファイルと一致する", "空または空でない"],
          "why_prohibited": "If true by definition, it proves nothing."
        },
        "semantic_compound": {
          "description": "Criterion that appears single but implies multiple conditions",
          "examples": ["API レスポンスの形式が仕様通り（=API稼働+JSON有効+スキーマ準拠）", "ビルドが成功する（=依存解決+コンパイル+リンク）"],
          "why_prohibited": "Decompose high-level concepts into atomic testable units."
        }
      },
      "SELF_CHECK": [
        "Can this criterion fail? If not, it's hollow.",
        "Does this criterion test exactly one thing? If not, split it.",
        "Is this describing state (what IS) or action (what TO DO)? Must be state.",
        "Would a hollow implementation pass this? If yes, strengthen.",
        "Does the command test the SPECIFIC noun in the criterion, not a proxy?"
      ]
    },
    "command": {
      "MUST": [
        "Be a valid shell command that can be copy-pasted and executed",
        "Return a verifiable exit code or output",
        "Test exactly one condition (no && or ; chaining)",
        "Use fresh/current data, not cached artifacts"
      ],
      "PROHIBITED_PATTERNS": {
        "pseudo_command": {
          "description": "Instructions disguised as commands",
          "examples": ["Execute the test", "Compare with expected", "Manually verify"],
          "why_prohibited": "Not executable. Must be actual shell command."
        },
        "compound_command": {
          "description": "Multiple commands chained together",
          "examples": ["test -f path && grep -q 'pattern' path", "cmd1; cmd2"],
          "why_prohibited": "Which command failed? Split into separate validations."
        },
        "trivial_command": {
          "description": "Commands that always succeed",
          "examples": ["echo 'done'", "true", "exit 0"],
          "why_prohibited": "Proves nothing. Command must actually test something."
        },
        "output_filtering": {
          "description": "Commands that hide failures through filtering",
          "examples": ["grep -v 'error'", "|| true", "|| echo 0", "2>/dev/null (hiding errors)"],
          "why_prohibited": "Hides evidence of failure. Output must be unfiltered."
        },
        "stale_check": {
          "description": "Checking cached/old artifacts without regeneration",
          "examples": ["test -d dist (without preceding build)", "cat old-log.txt"],
          "why_prohibited": "May pass on stale success. Validate current state."
        }
      },
      "SELF_CHECK": [
        "Can I paste this into a terminal right now? If not, rewrite.",
        "Does this command test exactly one thing?",
        "Can this command fail when the criterion is not met?",
        "Is the output unfiltered? No grep -v, || true, or error suppression?",
        "Am I testing fresh output, not cached artifacts?"
      ]
    },
    "expected": {
      "MUST": [
        "Be a concrete, observable value or exit code",
        "Be comparable by machine (not human interpretation)",
        "Reject at least 50% of possible outcomes (meaningful threshold)"
      ],
      "PROHIBITED_PATTERNS": {
        "subjective_expected": {
          "description": "Values requiring human judgment",
          "examples": ["適切な値", "正常終了", "期待通り"],
          "why_prohibited": "Machine cannot evaluate 'appropriate'. Use concrete value."
        },
        "universal_expected": {
          "description": "Values that sound complete but mean nothing",
          "examples": ["All pass", "100% success", "No errors"],
          "why_prohibited": "What is 'all'? Define the specific check."
        },
        "vacuous_threshold": {
          "description": "Thresholds that almost anything passes",
          "examples": [">= 0", ">= 1 line", "not empty (on any file)", "any output"],
          "why_prohibited": "No meaningful quality gate. Threshold must exclude failures."
        }
      },
      "VALID_FORMS": ["exit 0", "exit 1", ">= N (where N > trivial)", "== N", "contains 'X'", "exact string"],
      "SELF_CHECK": [
        "What percentage of random inputs would pass this? If > 90%, too weak.",
        "Would a hollow implementation's output pass? If yes, strengthen."
      ]
    },
    "subtask": {
      "MUST": [
        "Represent exactly one state change",
        "Have exactly one criterion"
      ],
      "PROHIBITED_PATTERNS": {
        "omnibus_subtask": {
          "description": "A subtask that does too many things",
          "examples": ["ファイル作成、テスト追加、ドキュメント更新を行う"],
          "why_prohibited": "Which part failed? One subtask = one verifiable change."
        }
      }
    },
    "anti_fraud": {
      "hollow_implementation": {
        "description": "Code that appears to work but doesn't actually do anything",
        "examples": [
          "Hardcoding test answers",
          "Returning fixed values instead of computing",
          "Stubbing with empty implementations"
        ],
        "detection": "Run with inputs not in test cases. Does it still work?"
      },
      "test_tampering": {
        "description": "Modifying tests to pass instead of fixing implementation",
        "examples": [
          "Changing expected values to match actual errors",
          "Adding skip() to failing tests",
          "Removing assertions"
        ],
        "rule": "Fix implementation, not tests. Test changes require user approval."
      },
      "evidence_fabrication": {
        "description": "Creating fake evidence of completion",
        "examples": [
          "Manually writing 'PASS' in logs",
          "Copying old success outputs",
          "Editing timestamps"
        ],
        "rule": "Evidence must be from actual command execution, not manual creation."
      }
    },
    "semantic_integrity": {
      "principle": "The trinity (criterion, command, expected) must be semantically aligned",
      "checks": [
        "Criterion noun == Command target (criterion says 'auth logic', command tests 'auth logic' not 'any function')",
        "Criterion specificity <= Command specificity (if criterion is specific, command must be equally or more specific)",
        "Expected must reject hollow implementations (if empty stub would pass, expected is too weak)"
      ],
      "detection_questions": [
        "If I replace the implementation with an empty stub, would this validation pass?",
        "If I hardcode the expected output, would this validation pass?",
        "Does the command actually test what the criterion claims?"
      ]
    }
  },
  "format_version": "2.4",
  "meta": {
    "id": "example-playbook-id",
    "branch": "feat/example-feature",
    "created": "YYYY-MM-DD",
    "status": "draft",
    "review_profile": "standard",
    "reviewed": false,
    "reviewed_by": "",
    "roles": {
      "orchestrator": "claudecode",
      "worker": "codex",
      "reviewer": "coderabbit",
      "human": "user"
    }
  },
  "goal": {
    "summary": "Implement X to achieve Y (one sentence, specific)",
    "done_when": [
      {
        "criterion": "src/feature.ts が存在する",
        "command": "test -f src/feature.ts",
        "expected": "exit 0"
      },
      {
        "criterion": "src/feature.ts に export function X が含まれる",
        "command": "grep -c 'export function X' src/feature.ts",
        "expected": ">= 1"
      },
      {
        "criterion": "npm test が exit 0 で終了する",
        "command": "npm test",
        "expected": "exit 0"
      }
    ],
    "scope": {
      "includes": ["List specific files or features"],
      "excludes": ["List what is NOT in scope"]
    }
  },
  "context": {
    "analysis_result": {
      "source": "prompt-analyzer",
      "data": {}
    },
    "user_approved_understanding": {
      "source": "",
      "approved_at": "",
      "summary": "",
      "approved_items": [],
      "technical_requirements_confirmed": []
    }
  },
  "max_iterations": 5,
  "phases": [
    {
      "id": "p1",
      "name": "Implementation",
      "description": "Implement the core feature",
      "depends_on": [],
      "subtasks": [
        {
          "id": "p1.1",
          "criterion": "src/feature.ts が存在する",
          "executor": "codex",
          "coding": true,
          "validation_plan": {
            "technical": {
              "type": "automated",
              "command": "test -f src/feature.ts",
              "expected": "exit 0"
            },
            "consistency": {
              "type": "automated",
              "command": "grep -c 'import.*feature' src/index.ts",
              "expected": ">= 1"
            },
            "completeness": {
              "type": "automated",
              "command": "jq '.compilerOptions.strict' tsconfig.json",
              "expected": "true"
            }
          }
        }
      ]
    },
    {
      "id": "p_final",
      "name": "Final verification",
      "description": "Execute all done_when commands and verify results",
      "depends_on": ["p1"],
      "subtasks": [
        {
          "id": "p_final.1",
          "criterion": "src/feature.ts が存在する（done_when[0]）",
          "executor": "coderabbit",
          "coding": false,
          "validation_plan": {
            "technical": {
              "type": "automated",
              "command": "test -f src/feature.ts",
              "expected": "exit 0"
            },
            "consistency": {
              "type": "automated",
              "command": "ls -la src/feature.ts",
              "expected": "file exists"
            },
            "completeness": {
              "type": "automated",
              "command": "file src/feature.ts",
              "expected": "text"
            }
          }
        },
        {
          "id": "p_final.2",
          "criterion": "src/feature.ts に export function X が含まれる（done_when[1]）",
          "executor": "coderabbit",
          "coding": false,
          "validation_plan": {
            "technical": {
              "type": "automated",
              "command": "grep -c 'export function X' src/feature.ts",
              "expected": ">= 1"
            },
            "consistency": {
              "type": "automated",
              "command": "grep 'export function X' src/feature.ts",
              "expected": "not empty"
            },
            "completeness": {
              "type": "automated",
              "command": "wc -l src/feature.ts",
              "expected": ">= 1"
            }
          }
        },
        {
          "id": "p_final.3",
          "criterion": "npm test が exit 0 で終了する（done_when[2]）",
          "executor": "coderabbit",
          "coding": false,
          "validation_plan": {
            "technical": {
              "type": "automated",
              "command": "npm test",
              "expected": "exit 0"
            },
            "consistency": {
              "type": "automated",
              "command": "npm run test:unit",
              "expected": "exit 0"
            },
            "completeness": {
              "type": "automated",
              "command": "npm run lint",
              "expected": "exit 0"
            }
          }
        }
      ]
    }
  ],
  "final_tasks": []
}
